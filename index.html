<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Realistic 3D Tank Game</title>
<style>
  body { margin:0; overflow:hidden; }
  #healthBar { position:absolute; top:10px; left:10px; width:200px; height:20px; background:red; }
  #healthFill { width:100%; height:100%; background:lime; }
</style>
</head>
<body>
<div id="healthBar"><div id="healthFill"></div></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>

<script>
let scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,50,50);
camera.lookAt(0,0,0);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enablePan=false;
controls.maxPolarAngle=Math.PI/2;

// Lights
let dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(50,100,50);
dirLight.castShadow=true;
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404040));

// Ground
let groundMat = new THREE.MeshStandardMaterial({color:0x228B22});
let groundGeo = new THREE.PlaneGeometry(100,100);
let ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow=true;
scene.add(ground);

// Obstacles
let obstacles = [];
for(let i=0;i<10;i++){
  let boxGeo = new THREE.BoxGeometry(5,5,5);
  let boxMat = new THREE.MeshStandardMaterial({color:0x8B4513});
  let box = new THREE.Mesh(boxGeo, boxMat);
  box.position.set(Math.random()*80-40,2.5,Math.random()*80-40);
  box.castShadow=true;
  scene.add(box);
  obstacles.push(box);
}

// GLTF loader
let loader = new THREE.GLTFLoader();

let playerTank;
let enemyTanks = [];

loader.load('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Tank/glTF/Tank.gltf', function(gltf){
  playerTank = gltf.scene;
  playerTank.scale.set(2,2,2);
  playerTank.position.set(0,0,0);
  scene.add(playerTank);
  playerTank.health = 100;

  // Spawn enemies
  for(let i=0;i<3;i++){
    let enemy = playerTank.clone();
    enemy.position.set(Math.random()*50-25,0,Math.random()*50-25);
    enemy.health = 50; // weaker than player
    scene.add(enemy);
    enemyTanks.push(enemy);
  }

  animate();
});

// Controls
const keys = {};
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// Simple movement & collision
function movePlayer(){
  if(!playerTank) return;
  let speed=0.2;
  if(keys['w']) playerTank.position.z -= speed;
  if(keys['s']) playerTank.position.z += speed;
  if(keys['a']) playerTank.position.x -= speed;
  if(keys['d']) playerTank.position.x += speed;

  obstacles.forEach(obs=>{
    if(playerTank.position.distanceTo(obs.position)<3){
      if(keys['w']) playerTank.position.z += speed;
      if(keys['s']) playerTank.position.z -= speed;
      if(keys['a']) playerTank.position.x += speed;
      if(keys['d']) playerTank.position.x -= speed;
    }
  });
}

// Enemy AI
function enemyAI(){
  if(!playerTank) return;
  enemyTanks.forEach(enemy=>{
    if(enemy.health<=0) return;
    let dir = new THREE.Vector3();
    dir.subVectors(playerTank.position, enemy.position).normalize();
    enemy.position.addScaledVector(dir,0.1);
    obstacles.forEach(obs=>{
      if(enemy.position.distanceTo(obs.position)<3){
        enemy.position.addScaledVector(dir,-0.1);
      }
    });
    if(enemy.position.distanceTo(playerTank.position)<5){
      playerTank.health -=0.05; // weak attacks
    }
  });
}

// Animate
const healthFill = document.getElementById('healthFill');
function animate(){
  requestAnimationFrame(animate);
  movePlayer();
  enemyAI();
  if(playerTank) healthFill.style.width = ((playerTank.health||0)/100*100)+'%';
  renderer.render(scene,camera);
}
</script>
</body>
</html>
